using UnityEngine;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Manages the logical state of the data pipeline, including all nodes and connections.
/// </summary>
public class PipelineManager : MonoBehaviour
{
    // Event to notify other systems (like the visualizer) when a connection is made.
    public static event System.Action<NodeBase, NodeBase> OnConnectionMade;

    private Dictionary<int, NodeBase> nodes = new Dictionary<int, NodeBase>();
    // The connections are stored as a dictionary where the key is the source node ID
    // and the value is a list of target node IDs.
    private Dictionary<int, List<int>> connections = new Dictionary<int, List<int>>();

    void Start()
    {
        Debug.Log("PipelineManager Initialized. Ready to build data flows.");
    }

    /// <summary>
    /// Adds a node to the pipeline. This should be called when a node is instantiated.
    /// </summary>
    /// <param name="node">The node to add.</param>
    public void AddNode(NodeBase node)
    {
        if (!nodes.ContainsKey(node.nodeData.id))
        {
            nodes.Add(node.nodeData.id, node);
            Debug.Log($"Node added: ID={node.nodeData.id}, Type={node.nodeData.nodeType}");
        }
        else
        {
            Debug.LogWarning($"Node with ID {node.nodeData.id} already exists.");
        }
    }

    /// <summary>
    /// Connects two nodes in the pipeline, creating a directed edge.
    /// </summary>
    /// <param name="fromId">The ID of the source node.</param>
    /// <param name="toId">The ID of the target node.</param>
    public void ConnectNodes(int fromId, int toId)
    {
        if (nodes.ContainsKey(fromId) && nodes.ContainsKey(toId))
        {
            if (!connections.ContainsKey(fromId))
            {
                connections[fromId] = new List<int>();
            }
            connections[fromId].Add(toId);

            // Fire the event to notify listeners that a connection was made
            OnConnectionMade?.Invoke(nodes[fromId], nodes[toId]);
        }
        else
        {
            Debug.LogError($"Cannot connect nodes. One or both IDs not found: fromId={fromId}, toId={toId}");
        }
    }

    /// <summary>
    /// Calculates the final output flow of the entire pipeline.
    /// This simple model calculates total source generation and then applies a global
    /// efficiency modifier based on all filter nodes in the system.
    /// A more complex model would traverse the graph.
    /// </summary>
    /// <returns>The final calculated flow rate.</returns>
    public float CalculateFlow()
    {
        float sourceFlow = 0f;
        // Step 1: Calculate the total flow generated by all data sources.
        foreach (var node in nodes.Values)
        {
            if (node is DataSourceNode dataSource)
            {
                sourceFlow += dataSource.generationRate;
            }
        }

        float pipelineEfficiency = 1.0f;
        // Step 2: Calculate the combined efficiency of all filters in the pipeline.
        foreach (var node in nodes.Values)
        {
            if (node is FilterNode filter)
            {
                pipelineEfficiency *= filter.throughput;
            }
        }

        // Step 3: The final flow is the source flow affected by the total efficiency.
        float finalFlow = sourceFlow * pipelineEfficiency;

        return finalFlow;
    }

    // Helper method to get a node by its ID.
    public NodeBase GetNodeById(int id)
    {
        nodes.TryGetValue(id, out NodeBase node);
        return node;
    }
}
